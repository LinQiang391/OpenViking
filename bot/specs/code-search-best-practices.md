# 代码搜索最佳做法借鉴

## 概述

本文档从多个高星 AI 编码助手项目（Oh My OpenCode、Plandex、Probe、Goose、Codex）中提炼代码搜索的最佳实践和重要做法，供系统设计参考。

---

## 一、多工具协同搜索策略

### 1.1 三层搜索架构

**借鉴项目**: Oh My OpenCode

```
搜索策略
    ↓
[文本层] - grep/ripgrep
    (快速关键字匹配)
    ↓
[结构层] - tree-sitter/ast-grep
    (代码结构理解)
    ↓
[文件层] - glob
    (文件模式匹配)
```

**核心要点**:
1. **文本搜索** - 用于快速找到包含关键字的文件和行
2. **结构搜索** - 用于理解代码模式（函数、类、结构）
3. **文件搜索** - 用于按名称/扩展名定位文件

**并行执行原则**:
- 必须在第一次行动中启动 3+ 工具同时执行
- 除非输出依赖于先前结果，否则绝不顺序执行
- 跨多个工具交叉验证发现

### 1.2 工具策略矩阵

| 搜索类型 | 推荐工具 | 使用场景 |
|---------|---------|---------|
| 语义搜索（定义、引用） | LSP 工具 | 查找函数定义、类引用 |
| 结构模式（函数形状、类结构） | ast_grep_search | 查找代码结构模式 |
| 文本模式（字符串、注释、日志） | grep | 查找特定文本内容 |
| 文件模式（按名称/扩展名查找） | glob | 按文件名称模式查找 |
| 历史/演进（何时添加、谁修改） | git 命令 | 查看代码变更历史 |

---

## 二、Tree-sitter 集成模式

### 2.1 Tree-sitter 的三种高级应用模式

| 模式 | 借鉴项目 | 用途 | 核心技术 |
|-----|----------|------|---------|
| **搜索工具** | Oh My OpenCode | ast-grep 工具，结构模式搜索 | ast-grep CLI |
| **理解 + 生成 + 验证** | Plandex | 项目映射、语法验证、结构化编辑 | 内部 tree-sitter 集成 |
| **语义搜索 + 代码提取** | Probe | 稀疏行图、注释关联、解析器池 | tree-sitter 解析器 |

### 2.2 Tree-sitter 用于项目映射（Plandex）

**核心数据结构**:
```go
type FileMap struct {
    Definitions []Definition
}

type Definition struct {
    Type      string       // "function", "class", "key", "selector" 等
    Signature string       // 完整签名/头部（不含实现）
    Comments  []string     // 前面的注释
    Line      int          // 定义起始行号
    Children  []Definition // 可包含嵌套定义的父类型
}
```

**映射流程**:
```
文件路径 + 内容
    ↓
[检查文件映射支持]
    ↓
[获取语言]
    ↓
[tree-sitter 支持?]
    ├─ 否 → 特殊处理（Markdown）
    └─ 是 → 获取解析器
              ↓
         [主解析器解析]
              ↓
         [成功?]
              ├─ 否 → [回退解析器]
              └─ 是 → [映射节点]
```

**借鉴要点**:
1. **回退解析器** - 主语言失败时使用回退语言
2. **优雅降级** - 返回空映射而非失败
3. **特殊处理** - Markdown 等无 tree-sitter 的语言

### 2.3 Tree-sitter 用于语义搜索（Probe）

**稀疏行图优化**:
```rust
/// 稀疏行图，仅存储实际需要的行的映射
struct SparseLineMap {
    mappings: HashMap<usize, CachedNodeInfo>,
    populated_ranges: Vec<(usize, usize)>,
    base_offset: usize,
}
```

**优化原理**:
1. 只处理与目标行相交的 AST 节点
2. 为目标行周围创建缓冲区（BUFFER_SIZE = 10）
3. 跳过不相交的整个子树

**性能提升**:
- 避免昂贵的完整树遍历
- 内存使用大幅减少
- 构建时间显著缩短

**注释上下文查找策略**:
| 策略 | 用途 | 实现 |
|-----|------|------|
| **1. 下一个非注释兄弟** | 文档注释 → 函数/类 | 跳过所有注释兄弟，找到下一个非注释 |
| **2. 前一个兄弟** | 尾随注释 | 只在没有下一个兄弟时使用 |
| **3. 父链** | 块内注释 | 向上遍历找到可接受的父节点 |
| **4. 直接下一个节点** | 兜底 | 找到任何紧随其后的可接受节点 |

**语言 Trait 设计**:
```rust
pub trait LanguageImpl {
    /// 获取 tree-sitter 语言对象
    fn get_tree_sitter_language(&self) -> TSLanguage;
    
    /// 检查节点是否是可接受的容器/父实体
    fn is_acceptable_parent(&self, node: &Node) -> bool;
    
    /// 检查节点是否代表测试代码
    fn is_test_node(&self, node: &Node, source: &[u8]) -> bool;
    
    /// 查找节点的父函数/方法声明
    fn find_parent_function<'a>(&self, _node: Node<'a>) -> Option<Node<'a>>;
    
    /// 提取符号签名（不含实现体）
    fn get_symbol_signature(&self, _node: &Node, _source: &[u8]) -> Option<String>;
}
```

**借鉴要点**:
1. **每种语言有自己的实现** - `is_acceptable_parent` 定义什么是"完整的代码块"
2. **测试检测** - 自动识别测试文件/测试函数
3. **默认实现 + 语言覆盖** - 基础功能默认，各语言可覆盖

### 2.4 Tree-sitter 用于理解、生成、验证（Plandex）

**三种用途**:
1. **项目映射** - 生成代码库结构概览（定义、签名）
2. **语法验证** - 确保编辑后的代码语法正确
3. **结构化编辑** - AST 感知的代码修改

**借鉴要点**:
- **结构化编辑** - 基于 AST 的编辑，不会破坏语法
- **回退机制** - 主语言失败时使用回退语言
- **验证** - 应用后验证语法正确性

### 2.5 Tree-sitter 性能优化

| 优化技术 | 借鉴项目 | 实现方式 |
|---------|----------|---------|
| **解析器池** | Probe | 对象池，避免重复创建 |
| **AST 树缓存** | Probe | FNV-1a 哈希，内容验证 |
| **稀疏行图** | Probe | 只处理需要的行 |
| **文件映射缓存** | Plandex | 缓存已生成的映射 |
| **按需创建解析器** | Plandex | 解析器按需创建 |

**FNV-1a 哈希缓存**:
```rust
/// 计算内容的确定性哈希用于缓存验证
fn calculate_content_hash(content: &str) -> u64 {
    const FNV_OFFSET_BASIS: u64 = 14695981039346656037;
    const FNV_PRIME: u64 = 1099511628211;
    
    let mut hash = FNV_OFFSET_BASIS;
    for byte in content.bytes() {
        hash ^= byte as u64;
        hash = hash.wrapping_mul(FNV_PRIME);
    }
    hash
}
```

**借鉴要点**:
- 避免 DefaultHasher 的非确定性
- 确保程序运行间的一致缓存键
- 内容变更时自动失效

---

## 三、双引擎搜索架构

### 3.1 Ripgrep + Tree-sitter 组合（Probe）

**架构**:
```
用户查询
    ↓
[Ripgrep 快速筛选]
    ↓
文件: src/auth.rs
行: 42, 156, 203
    ↓
[Tree-sitter 精确提取]
    ↓
完整代码块:
  fn authenticate_user(...) { ... }
  (从行 38 到 87)
```

**两阶段搜索策略**:

#### 阶段 1: Ripgrep 快速筛选
- **目标**: 快速找到可能相关的文件和行
- **优点**: 极快、轻量、并行
- **操作**: 使用 RegexSet 进行多模式匹配

#### 阶段 2: Tree-sitter 精确提取
- **目标**: 理解代码结构，提取完整的代码块
- **优点**: 精确、上下文、完整
- **操作**: 为候选文件解析 AST，使用稀疏行图优化

**协同优势**:
| 特性 | Ripgrep | Tree-sitter | 协同效果 |
|-----|---------|-------------|---------|
| **速度** | ⚡ 极快 | 🐢 较慢 | Ripgrep 先筛选，Tree-sitter 只处理候选 |
| **精确度** | ❌ 文本匹配 | ✅ 结构理解 | Tree-sitter 确保提取正确的代码块 |
| **内存** | ✅ 轻量 | ⚠️ 需存 AST | 稀疏行图优化减少内存 |
| **上下文** | ❌ 无 | ✅ 完整层次 | Tree-sitter 提供父/子/兄弟关系 |
| **注释** | ❌ 纯文本 | ✅ 智能关联 | Tree-sitter 将注释与代码关联 |

**借鉴要点**:
1. **双引擎架构** - Ripgrep 速度 + Tree-sitter 精度
2. **先筛选后精确** - 先用快速工具缩小范围，再用精确工具处理候选
3. **并行搜索** - Ripgrep 可以同时扫描数千个文件

---

## 四、智能代理搜索

### 4.1 专业化搜索代理（Oh My OpenCode）

**Explore 代理核心特性**:
- **只读权限** - 禁止 write/edit/apply_patch/task/call_omo_agent
- **极低温度** - 0.1，确保输出高度一致和确定
- **结构化输出** - 机器可解析的 XML 标签
- **三步流程** - 意图分析、并行执行、结构化结果

**代理 Prompt 系统**:

**1. 意图分析**:
```xml
<analysis>
**Literal Request**: [What they literally asked]
**Actual Need**: [What they're really trying to accomplish]
**Success Looks Like**: [What result would let them proceed immediately]
</analysis>
```

**2. 结构化结果**:
```xml
<results>
<files>
- /absolute/path/to/file1.ts — [why this file is relevant]
- /absolute/path/to/file2.ts — [why this file is relevant]
</files>

<answer>
[Direct answer to their actual need, not just file list]
</answer>

<next_steps>
[What they should do with this information]
</next_steps>
</results>
```

**成功标准**:
- ✅ **路径** — 所有路径必须是绝对路径（以 / 开头）
- ✅ **完整性** — 找到所有相关匹配，而不仅仅是第一个
- ✅ **可操作性** — 调用者可以继续，无需询问后续问题
- ✅ **意图** — 解决他们的实际需求，而不仅仅是字面请求

**借鉴要点**:
1. **专业化代理** - Explore 代理专注于搜索，具有明确的权限边界
2. **极低温度设置** - 确保输出高度一致和确定
3. **结构化输出格式** - 机器可解析，便于后续处理
4. **意图分析** - 理解用户的真实需求，而不只是字面请求

### 4.2 多代理协作（Oh My OpenCode）

**核心代理团队**:
| 代理 | 角色 | 模式 | 温度 | 重点 |
|-----|------|------|------|------|
| **Sisyphus** | 主控 | superagent | 0.3 | 任务规划与协调 |
| **Explore** | 代码库探索 | subagent | 0.1 | 搜索和发现 |
| **Oracle** | 架构/调试 | subagent | 0.2 | 复杂问题咨询 |
| **Librarian** | 文档检索 | subagent | 0.1 | 外部资料查找 |
| **Frontend UI/UX** | 前端开发 | subagent | 0.7 | 前端特定任务 |
| **Hephaestus** | 自主深度工作 | superagent | 0.3 | 完整自主执行 |

**借鉴要点**:
1. **主控 + 专业子代理** - 一个主控协调多个专家
2. **代理权限边界** - 每个代理有明确的职责和权限
3. **温度配置** - 搜索代理用低温度，创造性代理用高温度

### 4.3 背景代理管理系统

**核心组件**:
| 组件 | 职责 |
|-----|------|
| 管理器 | 任务生命周期管理 |
| 调度器 | 创建和调度子会话 |
| 轮询器 | 检查任务状态 |
| 历史记录 | 跟踪任务历史 |
| 结果处理 | 处理任务完成 |
| 并发控制 | 限制并发数量 |

**任务状态机**:
```
pending → running → completed
         ↓
       failed
         ↓
       cancelled
```

**借鉴要点**:
1. **并发控制** - 基于代理类型的并发分组
2. **独立队列** - Explore 代理有独立的并发控制队列
3. **状态机管理** - 清晰的任务状态流转

---

## 五、上下文管理策略

### 5.1 2M Token 窗口的秘密（Plandex）

**不是一次性加载所有内容，而是**:
```
用户任务
    ↓
[Tree-sitter 项目映射]
    (快速理解代码库结构)
    ↓
[Planner 模型]
    (决定需要哪些文件)
    ↓
[按需加载]
    (只加载相关文件)
    ↓
[Drafter 模型]
    (使用 2M 窗口生成代码)
```

**借鉴要点**:
1. **不是一次性加载** - 避免上下文超限
2. **每步只加载需要的内容** - 智能决定需要什么
3. **累积上下文，但智能管理** - 保持上下文，但不超限
4. **使用 tree-sitter 项目映射理解结构** - 先理解结构，再决定加载什么

### 5.2 Token 计算方法

| 方法 | 精度 | 速度 | 用途 |
|-----|------|------|------|
| `GetNumTokensEstimate()` | 高 | 慢 | 精确计算 |
| `GetFastNumTokensEstimate()` | 中 | 快 | 快速估算 |
| `GetBytesToTokensEstimate()` | 低 | 极快 | 字节估算 |

**估算常量**:
```go
const EstimatedBytesPerToken = 4  // 假设平均 4 字节 = 1 token
```

**借鉴要点**:
1. **三种计算方法** - 根据场景选择精度和速度
2. **快速估算用于初步判断** - 先快速估算，再精确计算
3. **字节估算用于超大内容** - 极快，但精度低

### 5.3 上下文缓存策略

**跨 OpenAI、Anthropic、Google 模型缓存上下文**:
- 减少成本
- 降低延迟
- 提高响应速度

**借鉴要点**:
1. **跨提供商缓存** - 不只是单个提供商
2. **成本 + 延迟双优化** - 缓存同时优化两个指标

---

## 六、搜索结果结构化

### 6.1 结构化输出格式（Oh My OpenCode）

**所有 Explore 代理的输出都必须遵循**:
1. 机器可解析的 XML 标签
2. 绝对路径
3. 明确的答案部分
4. 下一步建议

**借鉴要点**:
1. **机器可解析** - 便于后续自动化处理
2. **绝对路径** - 避免歧义
3. **明确答案** - 不只是文件列表
4. **下一步建议** - 引导用户后续行动

### 6.2 代理-工具分离模式

```
代理层 (Explore Agent)
    ↓ 理解意图、策略决策
工具层 (grep/ast-grep/glob)
    ↓ 执行具体搜索
基础设施层 (ripgrep/ast-grep binaries)
```

**借鉴要点**:
1. **分层架构** - 代理、工具、基础设施分离
2. **代理理解意图** - 代理层做决策，工具层执行
3. **工具专业化** - 每个工具做一件事，做好一件事

---

## 七、安全限制与最佳实践

### 7.1 搜索工具安全限制

| 限制 | Grep | Glob | AST-Grep |
|-----|------|------|----------|
| 超时 | 60s | 60s | 60s |
| 最大输出 | 10MB | 100 文件 | - |
| 递归深度 | 限制 | 限制 | - |
| 文件大小 | 限制 | - | - |

**借鉴要点**:
1. **超时限制** - 防止长时间运行
2. **输出限制** - 防止内存溢出
3. **深度限制** - 防止递归过深
4. **大小限制** - 防止处理超大文件

### 7.2 自动安装与回退

**Ripgrep 安装流程**:
1. 检查系统是否已安装 ripgrep
2. 如果没有，检查是否有系统 grep
3. 如果都没有，自动从 GitHub 下载预编译二进制
4. 安装到用户本地目录

**AST-Grep 安装**:
- 支持 NAPI (Node.js 原生模块)
- 支持 CLI 二进制
- 多平台预编译包

**借鉴要点**:
1. **自动检测** - 先检查是否已安装
2. **多回退方案** - 主方案 → 次方案 → 自动下载
3. **多平台支持** - 预编译二进制支持多个平台

---

## 八、关键趋势与总结

### 8.1 关键趋势观察

**趋势 1: 从单代理到多代理**
- **2024-2025**: 单一代理主导
- **2025-2026**: 多代理协作成为主流
- **Oh My OpenCode** 展示了强大的多代理模式

**趋势 2: 本地优先**
- 隐私和安全考虑
- 用户希望完全控制
- 自带模型（BYOM）成为常见模式
- **Goose** 完全免费，只需自带模型

**趋势 3: Tree-sitter 成为标准**
- 几乎所有新项目都使用 tree-sitter
- 从简单的文本搜索到结构理解
- 30+ 语言支持成为基准

**趋势 4: 双引擎搜索**
- Ripgrep 速度 + Tree-sitter 精度
- 先筛选后精确
- 并行执行多个工具

**趋势 5: MCP 生态爆发**
- 从少数工具到 3000+ 工具
- **Goose** 展示了 MCP 的潜力
- 成为 AI 助手的标准集成协议

### 8.2 最佳做法总结

| 类别 | 最佳做法 | 借鉴项目 |
|-----|---------|----------|
| **搜索策略** | 三层搜索（文本 + 结构 + 文件） | Oh My OpenCode |
| **Tree-sitter** | 三种用途（搜索/理解/验证） | Probe/Plandex |
| **双引擎** | Ripgrep 先筛选，Tree-sitter 后精确 | Probe |
| **专业化代理** | 只读、低温度、结构化输出 | Oh My OpenCode |
| **多代理** | 主控 + 专业子代理 | Oh My OpenCode |
| **上下文管理** | 2M 窗口，按需加载 | Plandex |
| **结果格式化** | 机器可解析 XML，绝对路径 | Oh My OpenCode |
| **安全限制** | 超时、输出、深度、大小限制 | Oh My OpenCode |
| **自动安装** | 检测 → 回退 → 自动下载 | Oh My OpenCode |
| **缓存策略** | FNV-1a 哈希，内容验证 | Probe |
| **性能优化** | 稀疏行图、解析器池 | Probe |

---

## 结语

代码搜索的最佳实践正在快速演进，核心要点包括：

1. **多工具协同** - 不再是单一工具，而是文本 + 结构 + 文件的组合
2. **Tree-sitter 标准** - 从搜索到理解、生成、验证，tree-sitter 无处不在
3. **专业化代理** - 专门的搜索代理，明确的权限边界
4. **双引擎架构** - Ripgrep 速度 + Tree-sitter 精度
5. **本地优先** - 隐私和控制成为关键
6. **结构化输出** - 机器可解析，便于后续处理

这些最佳做法共同代表了代码搜索的未来方向。
